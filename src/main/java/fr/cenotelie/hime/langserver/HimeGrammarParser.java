/*******************************************************************************
 * Copyright (c) 2017 Association Cénotélie (cenotelie.fr)
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.0.1.0
 */

package fr.cenotelie.hime.langserver;

import fr.cenotelie.hime.redist.Symbol;
import fr.cenotelie.hime.redist.parsers.LRkAutomaton;
import fr.cenotelie.hime.redist.parsers.LRkParser;

/**
 * Represents a parser
 */
class HimeGrammarParser extends LRkParser {
    /**
     * The automaton for this parser
     */
    private static final LRkAutomaton commonAutomaton = LRkAutomaton.find(HimeGrammarParser.class, "HimeGrammarParser.bin");

    /**
     * Contains the constant IDs for the variables and virtuals in this parser
     */
    public static class ID {
        /**
         * The unique identifier for variable option
         */
        public static final int option = 0x001F;
        /**
         * The unique identifier for variable terminal_def_atom
         */
        public static final int terminal_def_atom = 0x0020;
        /**
         * The unique identifier for variable terminal_def_element
         */
        public static final int terminal_def_element = 0x0021;
        /**
         * The unique identifier for variable terminal_def_cardinalilty
         */
        public static final int terminal_def_cardinalilty = 0x0022;
        /**
         * The unique identifier for variable terminal_def_repetition
         */
        public static final int terminal_def_repetition = 0x0023;
        /**
         * The unique identifier for variable terminal_def_fragment
         */
        public static final int terminal_def_fragment = 0x0024;
        /**
         * The unique identifier for variable terminal_def_restrict
         */
        public static final int terminal_def_restrict = 0x0025;
        /**
         * The unique identifier for variable terminal_definition
         */
        public static final int terminal_definition = 0x0026;
        /**
         * The unique identifier for variable terminal_rule
         */
        public static final int terminal_rule = 0x0027;
        /**
         * The unique identifier for variable terminal_fragment
         */
        public static final int terminal_fragment = 0x0028;
        /**
         * The unique identifier for variable terminal_context
         */
        public static final int terminal_context = 0x0029;
        /**
         * The unique identifier for variable terminal_item
         */
        public static final int terminal_item = 0x002A;
        /**
         * The unique identifier for variable rule_sym_action
         */
        public static final int rule_sym_action = 0x002B;
        /**
         * The unique identifier for variable rule_sym_virtual
         */
        public static final int rule_sym_virtual = 0x002C;
        /**
         * The unique identifier for variable rule_sym_ref_params
         */
        public static final int rule_sym_ref_params = 0x002D;
        /**
         * The unique identifier for variable rule_sym_ref_template
         */
        public static final int rule_sym_ref_template = 0x002E;
        /**
         * The unique identifier for variable rule_sym_ref_simple
         */
        public static final int rule_sym_ref_simple = 0x002F;
        /**
         * The unique identifier for variable rule_def_atom
         */
        public static final int rule_def_atom = 0x0030;
        /**
         * The unique identifier for variable rule_def_context
         */
        public static final int rule_def_context = 0x0031;
        /**
         * The unique identifier for variable rule_def_element
         */
        public static final int rule_def_element = 0x0032;
        /**
         * The unique identifier for variable rule_def_tree_action
         */
        public static final int rule_def_tree_action = 0x0033;
        /**
         * The unique identifier for variable rule_def_repetition
         */
        public static final int rule_def_repetition = 0x0034;
        /**
         * The unique identifier for variable rule_def_fragment
         */
        public static final int rule_def_fragment = 0x0035;
        /**
         * The unique identifier for variable rule_def_choice
         */
        public static final int rule_def_choice = 0x0036;
        /**
         * The unique identifier for variable rule_definition
         */
        public static final int rule_definition = 0x0037;
        /**
         * The unique identifier for variable rule_template_params
         */
        public static final int rule_template_params = 0x0038;
        /**
         * The unique identifier for variable cf_rule_template
         */
        public static final int cf_rule_template = 0x0039;
        /**
         * The unique identifier for variable cf_rule_simple
         */
        public static final int cf_rule_simple = 0x003A;
        /**
         * The unique identifier for variable cf_rule
         */
        public static final int cf_rule = 0x003B;
        /**
         * The unique identifier for variable grammar_options
         */
        public static final int grammar_options = 0x003C;
        /**
         * The unique identifier for variable grammar_terminals
         */
        public static final int grammar_terminals = 0x003D;
        /**
         * The unique identifier for variable grammar_cf_rules
         */
        public static final int grammar_cf_rules = 0x003E;
        /**
         * The unique identifier for variable grammar_parency
         */
        public static final int grammar_parency = 0x003F;
        /**
         * The unique identifier for variable cf_grammar
         */
        public static final int cf_grammar = 0x0040;
        /**
         * The unique identifier for variable file
         */
        public static final int file = 0x0041;
        /**
         * The unique identifier for variable __axiom
         */
        public static final int __axiom = 0x0061;
        /**
         * The unique identifier for virtual range
         */
        public static final int range = 0x0046;
        /**
         * The unique identifier for virtual concat
         */
        public static final int concat = 0x004A;
        /**
         * The unique identifier for virtual emptypart
         */
        public static final int emptypart = 0x0057;
    }

    /**
     * The collection of variables matched by this parser
     * <p>
     * The variables are in an order consistent with the automaton,
     * so that variable indices in the automaton can be used to retrieve the variables in this table
     */
    private static final Symbol[] variables = {
            new Symbol(0x001F, "option"),
            new Symbol(0x0020, "terminal_def_atom"),
            new Symbol(0x0021, "terminal_def_element"),
            new Symbol(0x0022, "terminal_def_cardinalilty"),
            new Symbol(0x0023, "terminal_def_repetition"),
            new Symbol(0x0024, "terminal_def_fragment"),
            new Symbol(0x0025, "terminal_def_restrict"),
            new Symbol(0x0026, "terminal_definition"),
            new Symbol(0x0027, "terminal_rule"),
            new Symbol(0x0028, "terminal_fragment"),
            new Symbol(0x0029, "terminal_context"),
            new Symbol(0x002A, "terminal_item"),
            new Symbol(0x002B, "rule_sym_action"),
            new Symbol(0x002C, "rule_sym_virtual"),
            new Symbol(0x002D, "rule_sym_ref_params"),
            new Symbol(0x002E, "rule_sym_ref_template"),
            new Symbol(0x002F, "rule_sym_ref_simple"),
            new Symbol(0x0030, "rule_def_atom"),
            new Symbol(0x0031, "rule_def_context"),
            new Symbol(0x0032, "rule_def_element"),
            new Symbol(0x0033, "rule_def_tree_action"),
            new Symbol(0x0034, "rule_def_repetition"),
            new Symbol(0x0035, "rule_def_fragment"),
            new Symbol(0x0036, "rule_def_choice"),
            new Symbol(0x0037, "rule_definition"),
            new Symbol(0x0038, "rule_template_params"),
            new Symbol(0x0039, "cf_rule_template"),
            new Symbol(0x003A, "cf_rule_simple"),
            new Symbol(0x003B, "cf_rule"),
            new Symbol(0x003C, "grammar_options"),
            new Symbol(0x003D, "grammar_terminals"),
            new Symbol(0x003E, "grammar_cf_rules"),
            new Symbol(0x003F, "grammar_parency"),
            new Symbol(0x0040, "cf_grammar"),
            new Symbol(0x0041, "file"),
            new Symbol(0x004B, "__V75"),
            new Symbol(0x004C, "__V76"),
            new Symbol(0x004D, "__V77"),
            new Symbol(0x0050, "__V80"),
            new Symbol(0x0053, "__V83"),
            new Symbol(0x0056, "__V86"),
            new Symbol(0x0058, "__V88"),
            new Symbol(0x0059, "__V89"),
            new Symbol(0x005A, "__V90"),
            new Symbol(0x005B, "__V91"),
            new Symbol(0x005C, "__V92"),
            new Symbol(0x005E, "__V94"),
            new Symbol(0x0060, "__V96"),
            new Symbol(0x0061, "__axiom")};
    /**
     * The collection of virtuals matched by this parser
     * <p>
     * The virtuals are in an order consistent with the automaton,
     * so that virtual indices in the automaton can be used to retrieve the virtuals in this table
     */
    private static final Symbol[] virtuals = {
            new Symbol(0x0046, "range"),
            new Symbol(0x004A, "concat"),
            new Symbol(0x0057, "emptypart")};

    /**
     * Initializes a new instance of the parser
     *
     * @param lexer The input lexer
     */
    public HimeGrammarParser(HimeGrammarLexer lexer) {
        super(commonAutomaton, variables, virtuals, null, lexer);
    }
}
